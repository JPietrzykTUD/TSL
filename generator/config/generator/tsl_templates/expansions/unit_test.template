namespace test_kernels {
  template<
    VectorProcessingStyle {{ primitive_test['vector_name'] }}, 
    typename ResultT,
    {{ 'typename ParamT_' ~ case['implementation']['param_names']|join(', typename ParamT_') ~ ',' if case['implementation']['param_names']|length > 0 }}
    typename SizeT
  >
  struct test_{{ case['primitive_name'] }}_{{ case['test_name'] }} {
    static void apply(
      ResultT {{ case['implementation']['result_name'] }},
      {% for name in case['implementation']['param_names'] %}{{ ', ' if loop.index > 1 }}ParamT_{{ name }} {{ name }}{% endfor %}{{ ',' if case['implementation']['param_names']|length > 0 }}
      SizeT {{ case['implementation']['element_count_name'] }}
    ) {
      {{ case['implementation']['test'] }}
    }
  };
}

template<VectorProcessingStyle {{ primitive_test['vector_name'] }}>
bool test_{{ case['primitive_name'] }}_{{ case['test_name'] }}(void) {
  using namespace {{ tsl_namespace }};
  auto test_case_executor = {{ case['test_operation'] }}_{{ case['test_type'] }}_test_case<{{ primitive_test['vector_name'] }}>({{ case['element_count'] }});

  test_case_executor.initialize(
    {% for initialization in case['initialize'] %}[](auto {{ initialization['data_name'] }}, size_t {{ initialization['element_count_name'] }}) {    
      {{ initialization['implementation'] }}
    }{{ ',' if loop.index < case['initialize']|length }}
    {% endfor %}
  );
  test_case_executor.execute_test_kernel<test_kernels::test_{{ case['primitive_name'] }}_{{ case['test_name'] }}>();
  test_case_executor.execute_reference_lambda(
    [](
      auto {{ case['implementation']['result_name'] }}, 
      {% for name in case['implementation']['param_names'] %}{{ ', ' if loop.index > 1 }}ParamT_{{ name }} {{ name }}{% endfor %}{{ ',' if case['implementation']['param_names']|length > 0 }}
      auto {{ case['implementation']['element_count_name'] }}
    ) {
      {{ case['implementation']['reference'] }}
    }
  );
  return test_case_executor.validate();
}