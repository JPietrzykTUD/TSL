---
file_description: "TODO."
includes:
   - "<random>"
   - "<chrono>"
   - "<cstdint>"
   - "<cstddef>"
   - "<cstdlib>"
   - "<functional>"
   - "<algorithm>"
   - "<utility>"
   - "<type_traits>"
   - "<limits>"
   - '"catch.hpp"'
implementations:
  - |
    template<class ExecutorClass, typename T>
    class test_case_memory_buffer {
      public:
        using memory_t = typename ExecutorClass::ptr_t<T>;
        using base_t = T;
      private:
        static constexpr size_t fence_size = 128;
        using check_t = uint64_t;
        static constexpr check_t init_value = 0x7465737463617365ULL;
        static constexpr check_t canary_value = 0xff63616e617279ffULL;
      private:
        ExecutorClass & m_executor;
        size_t m_data_element_count;
        size_t m_data_bytes_count;
        size_t m_data_allocated_bytes_count;
        size_t m_data_allocated_element_count;
        size_t m_allocated_bytes_count;
        memory_t m_buffer;
      private:
        base_t * data() const {
          return reinterpret_cast<base_t*>(&m_buffer[0]);
        }
        base_t * end_data_ptr()  const {
          return reinterpret_cast<base_t*>(&m_buffer[m_data_allocated_element_count]);
        }
        void reset_data() {
          auto data = reinterpret_cast<check_t*>(data());
          for(size_t i = 0; i < m_data_allocated_bytes_count/sizeof(check_t); ++i) {
            data[i] = 0x7465737463617365ULL;
          }
        }
        void reset_fence() {
          auto suffix = reinterpret_cast<check_t*>(end_data_ptr());
          for(size_t i = 0; i < fence_size/sizeof(check_t); ++i) {
            suffix[i] = 0xff63616e617279ffULL;
          }
        }
        void reset() {
          reset_data();
          reset_fence();
        }
        bool fences_valid() {
          auto suffix = reinterpret_cast<check_t*>(end_data_ptr());
          for(size_t i = 0; i < fence_size/sizeof(check_t); ++i) {
            if(suffix[i] != canary_value) {
              std::cerr << "Suffix fence corrupted at index " << i << std::endl;
              return false;
            }
          }
          return true;
        }
      
      public:
        size_t data_element_count() const { return m_data_element_count; }
        size_t element_count() const { return m_allocated_bytes_count / sizeof(T); }
        memory_t buffer() const { 
          return m_buffer;
        }

      public:
        template<typename... Args>
        test_case_memory_buffer(
          ExecutorClass & executor,
          size_t data_element_count,
          Args&&... args
        ) : m_executor(executor),
            m_data_element_count(data_element_count),
            m_data_bytes_count{data_element_count*sizeof(T)},
            m_data_allocated_bytes_count(
              m_data_bytes_count + (sizeof(check_t) - m_data_bytes_count%sizeof(check_t))%sizeof(check_t)
            )
            m_data_allocated_element_count(m_data_allocated_bytes_count/sizeof(T)),
            m_allocated_bytes_count(
              m_data_allocated_bytes_count + fence_size
            ),
            m_buffer(
              m_executor.template allocate<T>(m_allocated_bytes_count / sizeof(T), std::forward<Args>(args)...)
            )
        {    }
        ~test_case_memory_buffer() {
          m_executor.deallocate(m_buffer);
        }
        friend class test_case_memory_handler<ExecutorClass, T>;
    };


    template<class ExecutorClass, typename T>
    class test_case_memory_handler;

    template<class ExecutorClass, typename T>
    class test_case_memory_handler<ExecutorClass, T, std::enable_if_t<ExecutorClass::needs_heterogenious_memory_access>> {
      public: 
        using buffer_t = test_case_memory_buffer<ExecutorClass, T>;
      protected:
        ExecutorClass & m_executor;
        buffer_t m_host;
        buffer_t m_device;
      public: 
        test_case_memory_handler(ExecutorClass & executor, size_t data_element_count)
        : m_executor(executor),
          m_host(executor, data_element_count, MEMORY_ON_HOST{}),
          m_device(executor, data_element_count, MEMORY_ON_DEVICE{})
        {}
      protected:
        void copy_from_host() {
          m_executor.copy(m_device.buffer(), m_host.buffer(), m_host.element_count());
        }
        void copy_to_host() {
          m_executor.copy(m_host.buffer(), m_device.buffer(), m_host.element_count());
        }
    };
    template<class ExecutorClass, typename T>
    class test_case_memory_handler<ExecutorClass, T, std::enable_if_t<!ExecutorClass::needs_heterogenious_memory_access>> {
      public: 
        using buffer_t = test_case_memory_buffer<ExecutorClass, T>;
      protected:
        ExecutorClass & m_executor;
        buffer_t m_host;
      public: 
        test_case_memory_handler(ExecutorClass & executor, size_t data_element_count)
        : m_executor(executor),
          m_host(executor, data_element_count)
        {}
      protected:
        void copy_from_host() { /*NOP*/ }
        void copy_to_host() { /*NOP*/ }
    };

    template<class Executor, typename T>
    class test_case_memory: public test_case_memory_handler<Executor, T> {
      public:
        using base_t = T;
        using initialize_lambda_t = std::function<void(base_t *, size_t)>;
      public:
        test_case_memory(Executor & executor, size_t data_element_count):
          test_case_memory_handler<Executor, T>(executor, data_element_count)
        {}
      public:
        void initialize(auto&& fun) {
          m_host.reset();
          fun(this->m_host.buffer(), this->m_host.data_element_count());
          this->copy_from_host();
        }
        bool check_validity() {
          this->copy_to_host();
          return this->m_host.fences_valid();
        }

        auto buffer() const {
          return this->m_host.buffer();
        }
        auto element_count() const {
          return this->m_host.data_element_count();
        }
    };

    template<VectorProcessingStyle PS>
    class test_case {
      public:
        using base_t = typename PS::base_type;
        using test_executor_t = typename runtime::executor_helper_t<typename PS::target_extension>::type;
        using test_memory_t = test_case_memory<executor_t, base_type>;

        using reference_executor_t = typename runtime::executor_helper_t<scalar>::type;
        using reference_memory_t = test_case_memory<reference_executor_t, base_type>;
      
      protected:
        test_executor_t      m_executor;
        reference_executor_t m_reference_executor;
        test_memory_t        m_test_result;
        reference_memory_t   m_reference_result;

      public:
        explicit test_case(size_t result_element_count)
        : m_executor(test_executor_t()),
          m_reference_executor(reference_executor_t()),
          m_test_result(m_executor, result_element_count),
          m_reference_result(m_reference_executor, result_element_count)
        {}
        bool validate() {
          if (!m_test_result.check_validity()) {
            std::cerr << "Test result buffer corrupted" << std::endl;
            return false;
          }
          if (!m_reference_result.check_validity()) {
            std::cerr << "Reference result buffer corrupted" << std::endl;
            return false;
          }
          auto test_result = m_test_result.buffer();
          auto reference_result = m_reference_result.buffer();
          for (size_t i = 0; i < m_reference_result.element_count(); ++i) {
            if (test_result[i] != reference_result[i]) {
              std::cerr << "Data mismatch at index " << i << std::endl;
              std::cerr << "Test result: " << test_result[i] << std::endl;
              std::cerr << "Reference result: " << reference_result[i] << std::endl;
              return false;
            }
          }
          return true;
        }
    };

    template<VectorProcessingStyle PS>
    class unary_test_case : public test_case<PS>{
      protected:
        test_memory_t        m_data;
        reference_memory_t   m_reference_data;
      public:
        explicit unary_test_case(size_t data_element_count, size_t result_element_count) 
        : test_case<PS>(result_element_count),
          m_data(this->m_executor, data_element_count),
          m_reference_data(this->m_reference_executor, data_element_count)   
        {}
        void initialize(auto&& fun) {
          m_data.initialize(fun);
          m_reference_data.initialize(fun);
        }
        template<template<typename...> class Fun>
        void execute_test_kernel() {
          this->m_executor.template submit<Fun, PS>(this->m_test_result.buffer(), m_data.buffer(), m_data.element_count());
        }
        void execute_reference_lambda(auto && fun) {
          fun(this->m_reference_result.buffer(), m_reference_data.buffer(), m_reference_data.element_count());
        }
    };

    template<VectorProcessingStyle PS>
    class map_unary_test_case : public unary_test_case<PS> {
      public:
        explicit map_unary_test_case(size_t data_element_count)
          : unary_test_case<PS>(data_element_count, data_element_count)
        {}
    };

    template<VectorProcessingStyle PS>
    class reduce_unary_test_case : public unary_test_case<PS> {
      public:
        explicit reduce_unary_test_case(size_t data_element_count)
          : unary_test_case<PS>(data_element_count, 1)
        {}
    };

    template<VectorProcessingStyle PS>
    class filter_unary_test_case : public unary_test_case<PS> {
      public:
        explicit filter_unary_test_case(size_t data_element_count, size_t result_element_count)
          : unary_test_case<PS>(data_element_count, result_element_count)
        {}
    };

    template<VectorProcessingStyle PS>
    class binary_test_case : public test_case<PS>{
      protected:
        test_memory_t        m_data_first;
        test_memory_t        m_data_second;
        reference_memory_t   m_reference_data_first;
        reference_memory_t   m_reference_data_second;
      public:
        explicit binary_test_case(size_t data_element_count, size_t result_element_count) 
        : test_case<PS>(result_element_count),
          m_data_first(this->m_executor, data_element_count),
          m_data_second(this->m_executor, data_element_count),
          m_reference_data_first(this->m_reference_executor, data_element_count),
          m_reference_data_second(this->m_reference_executor, data_element_count)
        {}
        void initialize(auto&& fun1, auto&& fun2) {
          m_data_first.initialize(fun1);
          m_reference_data_first.initialize(fun1);
          m_data_second.initialize(fun2);
          m_reference_data_second.initialize(fun2);
        }
        template<template<typename...> class Fun>
        void execute_test_kernel() {
          this->m_executor.template submit<Fun, PS>(this->m_test_result.buffer(), m_data_first.buffer(), m_data_second.buffer(), m_data_first.element_count());
        }
        void execute_reference_lambda(auto && fun) {
          fun(this->m_reference_result.buffer(), m_reference_data.buffer(), m_reference_data.element_count());
        }
    };

    template<VectorProcessingStyle PS>
    class map_binary_test_case : public binary_test_case<PS> {
      public:
        explicit map_binary_test_case(size_t data_element_count)
          : binary_test_case<PS>(data_element_count, data_element_count)
        {}
    };

    template<VectorProcessingStyle PS>
    class reduce_binary_test_case : public binary_test_case<PS> {
      public:
        explicit reduce_binary_test_case(size_t data_element_count)
          : binary_test_case<PS>(data_element_count, 1)
        {}
    };

    template<VectorProcessingStyle PS>
    class filter_binary_test_case : public binary_test_case<PS> {
      public:
        explicit filter_binary_test_case(size_t data_element_count, size_t result_element_count)
          : binary_test_case<PS>(data_element_count, result_element_count)
        {}
    };
  - |
      template<typename T>
      void rnd_init_bounded(
          T* data, std::size_t element_count, T min_inclusive, T max_inclusive
      ) {
          std::mt19937 engine(std::chrono::high_resolution_clock::now().time_since_epoch().count());
          using dist_type = std::conditional_t< std::is_floating_point_v<T>, std::uniform_real_distribution<T>, std::uniform_int_distribution<T>>;
          dist_type dist(min_inclusive, max_inclusive);
          for(std::size_t i = 0; i < element_count; ++i) {
            data[i] = dist(engine);
          }
      }
  - |
    template<typename T>
    void rnd_init(T* data, std::size_t element_count) {
        rnd_init_bounded(
            data,
            element_count,
            static_cast<T>(0),
            std::clamp<T>(static_cast<T>(1000), static_cast<T>(0), static_cast<T>(std::numeric_limits<T>::max() / 3))
        );
    }
  - |
      template<typename T>
      void alternate_init_no_zero(T* data, std::size_t element_count) {
          T max =
            static_cast<T>(
                std::clamp<size_t>(
                  element_count,
                  static_cast<size_t>(std::numeric_limits<T>::lowest()),
                  static_cast<size_t>(std::numeric_limits<T>::max())
                )
            );
          T val = (T)1;
          size_t pos = 0;
          for(size_t i = 0; i < element_count/2; ++i) {
            data[pos++] = val;
            if constexpr (std::is_signed_v<T>) {
                data[pos++] = -val;
                if constexpr (std::is_floating_point_v<T>) {
                  ++val;
                } else {
                  val = (++val%max) == 0 ? 1 : val;
                }
            } else {
                val = (++val%max) == 0 ? 1 : val;
                data[pos++] = val;
                val = (++val%max) == 0 ? 1 : val;
            }
          }
      }
  - |
      template<typename T>
      void alternate_init(T* data, std::size_t element_count) {
          T max =
            static_cast<T>(
                std::clamp<size_t>(
                  element_count,
                  static_cast<size_t>(std::numeric_limits<T>::lowest()),
                  static_cast<size_t>(std::numeric_limits<T>::max())
                )
            );
          T val = (T)1;
          data[0] = (T)0;
          size_t pos = 1;
          for(size_t i = 1; i < element_count/2; ++i) {
            data[pos++] = val;
            if constexpr (std::is_signed_v<T>) {
                data[pos++] = -val;
                if constexpr (std::is_floating_point_v<T>) {
                  ++val;
                } else {
                  val = (++val%max) == 0 ? 1 : val;
                }
            } else {
                val = (++val%max) == 0 ? 1 : val;
                data[pos++] = val;
                val = (++val%max) == 0 ? 1 : val;
            }
          }
      }
  - |
      template<typename T>
      void seq_init_start_0(T* data, std::size_t element_count) {
          for(std::size_t i = 0; i < element_count; ++i) {
            data[i] = i;
          }
      }
  - |
      template<typename T>
      void seq_init_start_low(T* data, std::size_t element_count) {
          T current_value = std::numeric_limits<T>::lowest();
          for(std::size_t i = 0; i < element_count; ++i) {
            data[i] = current_value++;
          }
      }
  - |
      template<typename T>
      void seq_init(T* data, std::size_t element_count, T start) {
          T current_value = start;
          for(std::size_t i = 0; i < element_count; ++i) {
            data[i] = current_value;
            current_value = current_value + (T)1;
          }
      }
  - |
      template<typename T>
      bool check_value(T base, T to_be_examined) {
          if constexpr(std::is_integral_v<T>) {
            if constexpr(std::is_unsigned_v<T>) {
                if(base >= to_be_examined) {
                  return ((base - to_be_examined) == std::numeric_limits<T>::epsilon());
                } else {
                  return ((to_be_examined - base) == std::numeric_limits<T>::epsilon());
                }
            } else {
                return (std::abs(static_cast<T>(base - to_be_examined)) == std::numeric_limits<T>::epsilon());
            }
          } else {
            if (std::isnan(base)) return std::isnan(to_be_examined);
            return (std::fabs(static_cast<T>(base - to_be_examined)) <= std::numeric_limits<T>::epsilon());
          }
      }
  - |
      template<VectorProcessingStyle Vec>
      class set_call_helper_t {
          private:
            template<std::size_t... Is>
            static auto call_set_impl(typename Vec::base_type const * data, std::index_sequence<Is...>) {
                return tsl::set<Vec>((typename Vec::base_type)data[(Vec::vector_element_count()-1)-Is]...);
            }
          public:
            static auto call_set(typename Vec::base_type const * data) {
                return call_set_impl(data, std::make_index_sequence<Vec::vector_element_count()>{});
            }
      };
  - |
      template<VectorProcessingStyle Vec, VectorProcessingStyle outVec = Vec>
      class test_memory_helper_t {
          public:
            using base_t = typename Vec::base_type;
            using result_t = typename outVec::base_type;
          private:
            std::size_t const m_data_element_count;
            std::size_t const m_result_count;
            base_t * const m_data_ref;
            base_t * const m_data_target;
            result_t * const m_result_ref;
            result_t * const m_result_target_for_ref;
            result_t * const m_result_target;
          public:
            explicit test_memory_helper_t(std::size_t p_result_count, bool aligned):
                m_data_element_count   {0},
                m_result_count         {p_result_count},
                m_data_ref             {nullptr},
                m_data_target          {nullptr},
                m_result_ref           {tsl::allocate<tsl::simd<result_t, tsl::scalar>>(p_result_count*sizeof(result_t))},
                m_result_target_for_ref{tsl::allocate<tsl::simd<result_t, tsl::scalar>>(p_result_count*sizeof(result_t))},
                m_result_target        {(aligned) ? tsl::allocate_aligned<Vec>(p_result_count*sizeof(result_t), Vec::vector_alignment()) : tsl::allocate<Vec>(p_result_count*sizeof(result_t))}
            {
                std::memset(reinterpret_cast<void*>(m_result_ref), 0, p_result_count*sizeof(result_t));
            }
            test_memory_helper_t(std::size_t p_data_element_count, std::size_t p_result_count, bool aligned, std::function<void(base_t*, std::size_t)> const& fun = rnd_init<typename Vec::base_type>):
                m_data_element_count   {p_data_element_count},
                m_result_count         {p_result_count},
                m_data_ref             {tsl::allocate<tsl::simd<base_t, tsl::scalar>>(p_data_element_count*sizeof(base_t))},
                m_data_target          {(aligned) ? tsl::allocate_aligned<Vec>(p_data_element_count*sizeof(base_t), Vec::vector_alignment()) : tsl::allocate<Vec>(p_data_element_count*sizeof(base_t))},
                m_result_ref           {tsl::allocate<tsl::simd<result_t, tsl::scalar>>(p_result_count*sizeof(result_t))},
                m_result_target_for_ref{tsl::allocate<tsl::simd<result_t, tsl::scalar>>(p_result_count*sizeof(result_t))},
                m_result_target        {(aligned) ? tsl::allocate_aligned<Vec>(p_result_count*sizeof(result_t), Vec::vector_alignment()) : tsl::allocate<Vec>(p_result_count*sizeof(result_t))}
            {
                fun(m_data_ref, p_data_element_count);
                tsl::memory_cp<Vec>(m_data_target, m_data_ref, p_data_element_count*sizeof(base_t), 1);
                std::memset(reinterpret_cast<void*>(m_result_ref), 0, p_result_count*sizeof(result_t));
            }
            template<typename... Ts>
            test_memory_helper_t(std::size_t p_data_element_count, std::size_t p_result_count, bool aligned, void (*fun)(base_t*, std::size_t, Ts...), Ts... init_args):
                m_data_element_count   {p_data_element_count},
                m_result_count         {p_result_count},
                m_data_ref             {tsl::allocate<tsl::simd<base_t, tsl::scalar>>(p_data_element_count*sizeof(base_t))},
                m_data_target          {(aligned) ? tsl::allocate_aligned<Vec>(p_data_element_count*sizeof(base_t), Vec::vector_alignment()) : tsl::allocate<Vec>(p_data_element_count*sizeof(base_t))},
                m_result_ref           {tsl::allocate<tsl::simd<result_t, tsl::scalar>>(p_result_count*sizeof(result_t))},
                m_result_target_for_ref{tsl::allocate<tsl::simd<result_t, tsl::scalar>>(p_result_count*sizeof(result_t))},
                m_result_target        {(aligned) ? tsl::allocate_aligned<Vec>(p_result_count*sizeof(result_t), Vec::vector_alignment()) : tsl::allocate<Vec>(p_result_count*sizeof(result_t))}
            {
                fun(m_data_ref, p_data_element_count, init_args...);
                tsl::memory_cp<Vec>(m_data_target, m_data_ref, p_data_element_count*sizeof(base_t), 1);
                std::memset(reinterpret_cast<void*>(m_result_ref), 0, p_result_count*sizeof(result_t));
            }
            template<typename... Ts>
            test_memory_helper_t(std::size_t p_data_element_count, std::size_t p_result_count, bool aligned, std::function<void(base_t*,std::size_t, base_t)> const & fun, base_t start):
              m_data_element_count   {p_data_element_count},
              m_result_count         {p_result_count},
              m_data_ref             {tsl::allocate<tsl::simd<base_t, tsl::scalar>>(p_data_element_count*sizeof(base_t))},
              m_data_target          {(aligned) ? tsl::allocate_aligned<Vec>(p_data_element_count*sizeof(base_t), Vec::vector_alignment()) : tsl::allocate<Vec>(p_data_element_count*sizeof(base_t))},
              m_result_ref           {tsl::allocate<tsl::simd<result_t, tsl::scalar>>(p_result_count*sizeof(result_t))},
              m_result_target_for_ref{tsl::allocate<tsl::simd<result_t, tsl::scalar>>(p_result_count*sizeof(result_t))},
              m_result_target        {(aligned) ? tsl::allocate_aligned<Vec>(p_result_count*sizeof(result_t), Vec::vector_alignment()) : tsl::allocate<Vec>(p_result_count*sizeof(result_t))}
            {
              fun(m_data_ref, p_data_element_count, start);
              tsl::memory_cp<Vec>(m_data_target, m_data_ref, p_data_element_count*sizeof(base_t), 1);
              std::memset(reinterpret_cast<void*>(m_result_ref), 0, p_result_count*sizeof(result_t));
            }
            virtual ~test_memory_helper_t() {
                tsl::deallocate<outVec>(m_result_target);
                tsl::deallocate<tsl::simd<result_t, tsl::scalar>>(m_result_target_for_ref);
                tsl::deallocate<tsl::simd<result_t, tsl::scalar>>(m_result_ref);
                if(m_data_element_count > 0) {
                  tsl::deallocate<Vec>(m_data_target);
                  tsl::deallocate<tsl::simd<base_t, tsl::scalar>>(m_data_ref);
                }
            }
          public:
            auto data_ref() const { return m_data_ref; }
            auto data_target() const { return m_data_target; }
            auto result_ref() { return m_result_ref; }
            auto result_target() { return m_result_target; }
          public:
            void ship_to_dev() {
                tsl::memory_cp<Vec>(m_data_target, m_data_ref, m_data_element_count*sizeof(base_t), 1);
            }
            void synchronize() {
                tsl::memory_cp<outVec>(m_result_target_for_ref, m_result_target, m_result_count*sizeof(result_t), 2);
            }
            bool validate() const {
                bool result = true;
                for(auto i = 0; i < m_result_count; ++i) {
                  //std::cerr << m_result_ref[i] << " " << m_result_target_for_ref[i] << std::endl;
                  result &= check_value<result_t>(m_result_ref[i], m_result_target_for_ref[i]);
                }
                return result;
            }
            bool validate_simd_register(typename outVec::register_type reg) const {
                auto tmp_target_buf = tsl::allocate_aligned<outVec>(outVec::vector_size_B(), outVec::vector_alignment());
                auto tmp_reference_buf = tsl::allocate<tsl::simd<base_t, tsl::scalar>>(outVec::vector_size_B());
                if constexpr(outVec::register_type_is_pointer_v) {
                  tsl::memory_cp<outVec>(tmp_target_buf, reinterpret_cast<typename outVec::base_type const *>(reg), outVec::vector_size_B(), 3);
                } else {
                  tsl::memory_cp<outVec>(tmp_target_buf, reinterpret_cast<typename outVec::base_type const *>(&reg), outVec::vector_size_B(), 3);
                }
                tsl::memory_cp<outVec>(tmp_reference_buf, tmp_target_buf, outVec::vector_size_B(), 2);
                bool result = true;
                for(auto i = 0; i < outVec::vector_element_count(); ++i) {
                  result &= check_value<base_t>(tmp_reference_buf[i], m_result_ref[i]);
                }
                tsl::deallocate<tsl::simd<base_t, tsl::scalar>>(tmp_reference_buf);
                tsl::deallocate<outVec>(tmp_target_buf);
                return result;
            }
      };
...
